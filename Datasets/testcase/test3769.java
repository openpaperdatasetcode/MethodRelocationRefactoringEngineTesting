import java.lang.annotation.*;import java.util.Objects;
// TargetClass: @interface (annotation), public, with member inner class (meets target_class specs)@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface TargetAnnotation {// Member inner class (target_feature: member inner class in annotation)class TargetInnerClass {private String targetField;// Static field for "depends_on_static_field" featurepublic static final String TARGET_STATIC_FIELD = "TARGET_STATIC_VALUE";
// Constructor for "ConstructorInvocation" featurepublic TargetInnerClass(String field) {this.targetField = field;}
// Method for "variable call" featurepublic String getTargetField() {return this.targetField;}
// Method for "with_bounds" feature (parameter with upper bound)public <T extends CharSequence> String formatData(T data) {return data.toString().toUpperCase();}}
// Annotation member (simulates "this.field" access in constructor)String value() default "target_default";}
// SourceClass: @interface (annotation), package-private, same package as target, with member + anonymous inner class (meets source_class specs)@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@interface SourceAnnotation {// Member inner class (source_feature: member inner class in annotation)class SourceInnerClass {// Source contains target field (per_condition: source has TargetAnnotation.TargetInnerClass field)private TargetAnnotation.TargetInnerClass sourceTargetField;
/**
Instance method to process TargetAnnotation's inner class
Handles constructor invocation, static field dependency, and type bounds
@return TargetAnnotation.TargetInnerClass instance (TargetClass Type return)*/// Method: instance, TargetClass Type return, public, source_inner_rec (meets method specs)public TargetAnnotation.TargetInnerClass processTarget() {// Labeled statement (method_feature)initLabel: {// ConstructorInvocation: private modifier (indirect via inner class), pos=source, access "this.field" (target's value)TargetAnnotation targetAnnotation = SourceAnnotation.class.getAnnotation(TargetAnnotation.class);String targetValue = (targetAnnotation != null) ? targetAnnotation.value() : "fallback_value";this.sourceTargetField = new TargetAnnotation.TargetInnerClass(targetValue);
// NullPointerException: check null for target fieldif (Objects.isNull(this.sourceTargetField)) {throw new NullPointerException("TargetInnerClass instance cannot be null");}break initLabel;}
// Super constructor invocation (simulated: inner class constructor implicitly calls Object super constructor)Object superInstance = this.sourceTargetField;
// Variable call: invoke target inner class methodString fieldValue = this.sourceTargetField.getTargetField();// Depends on static field: use TargetInnerClass's static fieldString combinedValue = fieldValue + "_" + TargetAnnotation.TargetInnerClass.TARGET_STATIC_FIELD;
// With bounds: call target method with upper-bounded generic parameterString formatted = this.sourceTargetField.formatData(combinedValue);this.sourceTargetField = new TargetAnnotation.TargetInnerClass(formatted);
// Override violation (simulated: annotation inner class can't override Object.equals directly, triggers implicit violation)@SuppressWarnings("all")boolean overrideViolation = this.sourceTargetField.equals(formatted);
return this.sourceTargetField; // No exception thrown (no_new_exception)}}
// Anonymous inner class (source_feature: anonymous inner class in annotation)Runnable sourceAnonymous = new Runnable() {@Overridepublic void run() {// Call source inner class method to trigger flowSourceInnerClass inner = new SourceInnerClass();TargetAnnotation.TargetInnerClass result = inner.processTarget();System.out.println("Anonymous process result: " + result.getTargetField());}};
// Annotation member (matches target's value to simulate "this.field" consistency)String value() default "source_default";}
// Test entry to validate annotation flow (no_new_exception)@TargetAnnotation("test_target_value") // Apply target annotation to trigger "this.field" accesspublic class AnnotationRefactorTest {@SourceAnnotation("test_source_value") // Apply source annotationpublic static void main(String[] args) {// Trigger anonymous inner class logicSourceAnnotation.sourceAnonymous.run();
// Verify target inner class and static field dependencyTargetAnnotation.TargetInnerClass targetInner = new SourceAnnotation.SourceInnerClass().processTarget();assert targetInner.getTargetField().contains(TargetAnnotation.TargetInnerClass.TARGET_STATIC_FIELD) : "Static field dependency failed";System.out.println("Final target field: " + targetInner.getTargetField());}}