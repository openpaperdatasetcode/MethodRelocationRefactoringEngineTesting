import java.util.Objects;
// TargetInterface: interface, package-private, with local inner class (meets target_class specs)interface TargetInterface {String getField();void setField(String field);
// Local inner class (target_feature)default TargetInterface createLocalInstance() {class LocalTargetImpl implements TargetInterface {private String localField;
@Overridepublic String getField() {return localField;}
@Overridepublic void setField(String field) {this.localField = field;}}return new LocalTargetImpl();}}
// SourceInterface: interface, package-private, same package as target, no extra features (meets source_class specs)interface SourceInterface {// Inner class for method_position: source_inner_recclass SourceInner {// Varargs method: meets method specs (varargs, void return, private, source_inner_rec)// Contains target parameter (per_condition)private void processTargets(TargetInterface... targets) {if (targets == null) {return;}
loop:for (int i = 0; i < targets.length; i++) {TargetInterface target = targets[i];// Type declaration statement (method_feature)TargetInterface newTarget = target.createLocalInstance();
// Continue statement (method_feature)if (i % 2 == 0) {continue loop;}
try {// Accessor method calls (3 times, source, accessor, new ClassName().method()) (method_feature)// 1st accessor callnew TargetInterface() {@Override public String getField() { return "accessor1"; }@Override public void setField(String f) {}}.getField();// 2nd accessor callnew TargetInterface() {@Override public String getField() { return "accessor2"; }@Override public void setField(String f) {}}.setField("data2");// 3rd accessor call (returns TargetClass Type)TargetInterface accessorResult = new TargetInterface() {@Override public String getField() { return "accessor3"; }@Override public void setField(String f) {}}.createLocalInstance();
// Super keywords (method_feature: access outer class context)Class<?> outerClass = SourceInner.this.getClass().getEnclosingClass();
// Synchronized statement (simulate private modifier effect)synchronized (target) {// Variable call (method_feature)target.setField("processed_" + i);// BreakStatement (method_feature: private modifier, pos=source, access super.field)if (target.getField().length() > 10) {break loop;}}} catch (Exception e) {// Exception handling statements (pos for accessor calls)e.printStackTrace();}}// No new exception (method_feature)}
// Public method to trigger varargs processingpublic void startProcessing(TargetInterface... targets) {processTargets(targets);}}
// Default method to create inner class instancedefault void initProcessing(TargetInterface... targets) {SourceInner inner = new SourceInner();inner.startProcessing(targets);}}
// Concrete implementation of SourceInterface for testingclass SourceImpl implements SourceInterface {}
// Test entrypublic class InterfaceRefactorTest {public static void main(String[] args) {SourceInterface source = new SourceImpl();TargetInterface t1 = new TargetInterface() {private String field;@Override public String getField() { return field; }@Override public void setField(String f) { this.field = f; }};TargetInterface t2 = new TargetInterface() {private String field;@Override public String getField() { return field; }@Override public void setField(String f) { this.field = f; }};
source.initProcessing(t1, t2); // No new exception}}