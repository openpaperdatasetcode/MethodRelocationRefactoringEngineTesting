import java.util.Arrays;
abstract class SourceClass {protected TargetClass targetField;
static class StaticNested {private abstract class InnerAbstract {@Deprecatedprivate abstract void methodToMove();}}
void someMethod() {class LocalInner {void localMethod() {Object obj = new Object() {Object handleExceptions() {int[] arr = new int[5];protected int access1 = arr[0];protected int access2 = arr[1];
synchronized (this) {new TargetClass().process();}
try {super.getClass();targetField.nested.new Inner().call();} catch (Exception e) {return null;}return new Object();}}.handleExceptions();}}
Runnable r = () -> {int result = targetField.new NestedInner().targetMethod();};}}
/**
Javadoc for TargetClass*/protected class TargetClass {{super();}
class NestedInner {int targetMethod() {return 0;}
class Inner {void call() {}}}
void process() {Runnable r = new Runnable() {public void run() {}};}}